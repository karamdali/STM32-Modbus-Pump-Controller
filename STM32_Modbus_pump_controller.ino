/*
 * Karam Dali 
 * Damascus 15-10-2024
 * Modbus RTU slave device using stm32f102 (bluepill) to control a 12v water pump and collect sensors data (current - flowmeter - vibration IMU)
 * This slave will connect to IOT gateway (ESP32) to transmite its data to an online server via mqtts and recive control command from the server.
*/

#include <Wire.h>                       //I2C for MPU6050.
#include <ModbusRTUSlave.h>             //Modbus RTU protocol to transmit data.
#include <math.h>


#define MPU_INT_PIN       PA0           //MPU INT pin is high when there is new data is ready to be read by stm32.
#define PUMP              PB3           //Digital out-put to control the pump ON or OFF.
#define CURRENT_SENSOR    PB1           //Analog read pin which we will read the current from it.
#define FLOW_METER        PA4           //Flow meter's signal pin.
#define RS485_CONTROL_PIN PA3           //DE+RE pins on MAX485 are connected to this pin.
                                        //The RE and DE Pins are responsible for setting the module in Receiver or Transmitter mode.
                                        //When the RE pin is LOW and DE pin is LOW, the Module is set in the Receiver mode.
                                        //When the DE pin is HIGH and RE pin is HIGH, the Module is set in the Transmitter mode.

const float x_skew_min = -1.47;
const float x_skew_max = 1.66;
const float y_skew_min = -1.9;
const float y_skew_max = 2.05;
const float z_skew_min = -1.07;
const float z_skew_max = 1.1937;


#define DEBUG             1


#if DEBUG
#include <HardwareSerial.h>
HardwareSerial Serial3(PB11,PB10);
#endif

const uint16_t samples = 128;           //Number of samples collected from MPU6050 on each axes x,y and z.


//Modbus RTU configuration.

ModbusRTUSlave modbus(Serial,RS485_CONTROL_PIN);
bool coils[1];                           //Stor the pump status ON/OFF.
uint16_t inputRegisters[12];  //x_skew,y_skew,z_skew,flow_rate,total_flow and current are 32bits float each needs a 2*uint16_t addresses to store it.
//x[0-1] y[2-3] z[4-5] current[6-7] flow_rate[8-9] total_flow[10-11].

union converter {
  float f;
  uint32_t u32;
};


//function to write float variable to uint16_t array (inputRegester).
void writeFloat(float value,uint16_t * array, int position){
  union converter var;
  var.f = value;
  array[position] = (uint16_t)(var.u32 & 0xFFFF);
  array[position+1] = (uint16_t)(var.u32>>16 & 0xFFFF);
}


//ACS712 Current sensor configuration.
//The output of the current sensor is connected to a voltage divider to prevent it from exceeding 3.3v on PB1 pin.
float R1 = 6500.0;
float R2 = 12000.0;
float current;

float getCurrent(){
  int ADC_PB1=0;
  for(int i=0;i<10;i++){
    ADC_PB1 += analogRead(CURRENT_SENSOR);
  }
  
  //Serial.print("ADC_PB1 = ");Serial.println(ADC_PB1/10);
  float adc_voltage = (ADC_PB1/10) * (3.3 / 1024);
  //Serial.print("adc_voltage = ");Serial.println(adc_voltage);
  float current_voltage = (adc_voltage * (R1+R2)/R2);
  //Serial.print("current_voltage = ");Serial.println(current_voltage);
  float current =  (current_voltage - 2.4) /0.185;
  /*
  #if DEBUG
    Serial3.print("ADC_PB1 = ");Serial3.println(ADC_PB1);
    Serial3.print("adc_voltage = ");Serial3.println(adc_voltage);
    Serial3.print("current_voltage = ");Serial3.println(current_voltage);
    Serial3.print("current = ");Serial3.println(current);  
  #endif
  */
  return current;
}


//YF-s401 Flow meter sensor configuration.

volatile int pulse_count = 0;           //Variable to store the number of pulses.
float flow_rate =0,flow_mil=0;          //Variable to store the flow rate in L/min.        
float total_flow = 0;                   //Variable to store the flow rate in L/min.
float calibration_factor = 550;          //The YF-S401 outputs 98 pulses per liter/minute of flow.
unsigned long t_previous = 0;

/*
  * YF-S401 Working principal.
  * The total volume of liquid flowing through the water flow sensor at a certain time t(unit s) as V_total(unit L), and the total number of pulses detected as N. Then we get: 
  * V_total (L) = N/98 : Where N is the number of pulses.
  *                            98 is the calibration factor of YF_s401 according to the datasheet.
  * Also, the total volume of fluid flowing through the water flow sensor is equal to the water flow rate(Q - unit L/s) multiplied by time t(unit s).
  * V_total(L) = Q(L/s)*t(s)
  * So, we getï¼š
  * N* 1/98 = Q(L/s)*t(s) 
  * N/t = 98 * Q(L/s)  
  * N/t happen to be frequency f, and it is in our case 1/time_interval :
  * f = 98*Q(L/s); 
  * Q(L/sec) = f/98; 
  * Q(L/min) = (f*60)/98 = f/0.612
  * 
*/

//Interrupt configuration.
//Function calcultes flow_rate and total_flow by the pump.
//This funtion will be excuted each time a pulse is generated by the YF-S401.
void pulseCounter() {                             
  pulse_count++;                        //Increment the pulse count (for total flow tracking).
}

void updateFlow(){
  /*
  #if DEBUG
    Serial3.print("pulse_count = ");Serial3.println(pulse_count);
  #endif
  */
  if(millis() - t_previous >1000){
    /*
    #if DEBUG
      Serial3.print("millis() - t_previous = ");Serial3.println(millis() - t_previous);
    #endif
    */
    flow_rate = ((1000.0 / (millis() - t_previous)) * pulse_count) / calibration_factor;
    pulse_count = 0;
    flow_mil = (flow_rate/60)*1000;
    total_flow += flow_mil;
    t_previous = millis();
  }
}

//MPU6050 Configuration.
#define MPU_ADDRESS       0x68          //Default I2C address of MPU6040 sensor if ADO pin was not used.

//MPU6050's regesters address value
#define PWR_MGMT_1        0x6B          //configure the power mode.
#define SIGNAL_PATH_RESET 0x68          //Reset the analog and digital signal paths of the gyroscope, accelerometer, and temperature sensors.
#define CONFIG            0x1A          //Configure digital low pass filter cut off frequency.
#define INT_ENABLE        0x38          //This register enables interrupt generation by interrupt sources.
#define INT_PIN_CFG       0x37          //This register configures the behavior of the interrupt signals at the INT pins.
#define ACCEL_CONFIG      0x1c          //This register is used to trigger accelerometer self test and configure the accelerometer full scale range.
#define ACCEL_XOUT_H      0x3b          //The first register of 6 that holds the accelerometer raw data.
#define SMPLRT_DIV        0x19          //This register specifies the divider from the gyroscope output rate used to generate the Sample Rate for the MPU-6050.

//MPU accelerometer's offset, we get those values by letting the sensro to run in a flat surface for a fixed duration and calculate the average of values.
int16_t xOffset = 355;
int16_t yOffset = 30;
int16_t zOffset = 68;

//Interrupt configuration
//When there are new data from MPU6050, INT pin of the sensor will be configured to be HIGH using INT_PIN_CFG and INT_PIN_CFG registers.
volatile bool data_ready = false;

//Interrupt function
void onDataReady() {
  data_ready = true;
}

//variable to store the accelerometer values on each axis
struct accValue{
    int16_t ax;
    int16_t ay;
    int16_t az;
}var;


int sample_index = 0;

void getAccReads(struct accValue *value){           //Get raw accelerometer data.
  Wire.beginTransmission(MPU_ADDRESS);
  Wire.write(ACCEL_XOUT_H);                         //First register address of 6 registers where raw accelerometer data is stored in MPU6050.
  Wire.endTransmission(false);
  Wire.requestFrom(MPU_ADDRESS, 6);
  
  value->ax = (Wire.read() << 8) | Wire.read();
  value->ay = (Wire.read() << 8) | Wire.read();
  value->az = (Wire.read() << 8) | Wire.read();
}

void writeRegister(uint8_t reg, uint8_t value){     //Used to write values to sensor's register to modify its configuration in the setup().
    Wire.beginTransmission(MPU_ADDRESS);
    Wire.write(reg);
    Wire.write(value);
    Wire.endTransmission();
    delay(100);                                    //Requested according to the datasheet
}

uint8_t readRegister(uint8_t reg){                 //Read register values used in debuging mode.
    Wire.beginTransmission(MPU_ADDRESS);
    Wire.write(reg);
    Wire.endTransmission(false);
    Wire.requestFrom(MPU_ADDRESS,1);
    return Wire.read(); 
}

void MPU6050Config(){
  //MPU 6050 configuration.
  
  writeRegister(PWR_MGMT_1, 0b10001000);            //Resets all internal registers, disables the temperature sensor.   
  writeRegister(SIGNAL_PATH_RESET, 0b00000111);     //Resets gyroscope/accelerometer/temperature sensor analog and digital signal paths.
  writeRegister(PWR_MGMT_1, 0b00000000);            //Re-enables the sensor after the reset.
  writeRegister(CONFIG, 0b00000011);                //Set the cut-off frequency of the digital low pass filter to  184Hz.
  writeRegister(ACCEL_CONFIG, 0b00000000);          //Sets the range for the accelerometer to +-2g.
  writeRegister(SMPLRT_DIV, 0b00000000);            //Sample_Rate = (Gyroscope Output Rate = 1KHz since we use DLPF by sitting the CONFIG register to 2 ) / (1 + SMPLRT_DIV=0) = 1000Hz
  //Configure MPU6050 Interrupt
  writeRegister(INT_ENABLE, 0x01);                  //Enables the Data Ready interrupt, which occurs each time a write operation to all of the sensor registers has been completed.
  writeRegister(INT_PIN_CFG, 0x10);                 //Interrupt status bits are cleared without the need to read INT_STATUS (Register 58).
}


//function to compute the skewness for the raw data of MPU6050 on each axis
float skew_(int* arr, float mean,int size) {      
    double m2 = 0.0;          //Second moment.
    double m3 = 0.0;          //Third moment.
    for (int i = 0; i < size; i++) {
        float diff = arr[i] - mean;
        m2 += diff * diff;
        m3 += diff * diff * diff;
    }
    m2 /= size;               //Variance.
    m3 /= size;               //Third moment.
    /*
    #ifdef DEBUG
        Serial3.print("m2 = ");Serial3.println(m2);
        Serial3.print("m3 = ");Serial3.println(m3);
      #endif
      */
    if (m2 == 0) {
      #ifdef DEBUG  
        Serial3.println("Variance is zero, skewness is undefined");
      #endif
      return 0.0;
    }
    float skewness = m3 / pow(m2, 1.5);
    return skewness;
}



struct MPU6050{
  int x[samples],y[samples],z[samples];
  float x_sum = 0 , y_sum = 0, z_sum = 0;
  float x_mean = 0, y_mean = 0, z_mean = 0;
  float x_skew, y_skew, z_skew;
}MPU;

int x_offset = 2147;
int y_offset = 442;
int z_offset = 14232;

void MPU6050Read(){
    while(1){
    if (data_ready) {
      data_ready = false;
      getAccReads(&var);
      MPU.x[sample_index] = var.ax;
      MPU.y[sample_index] = var.ay;
      MPU.z[sample_index] = var.az;
      MPU.x_sum += var.ax;
      MPU.y_sum += var.ay;
      MPU.z_sum += var.az;
      sample_index++;
      /*
      #ifdef DEBUG
        Serial3.print("x = ");Serial3.println(var.ax);
        Serial3.print("y = ");Serial3.println(var.ay);
        Serial3.print("z = ");Serial3.println(var.az);
      #endif
      */
    }
    if(sample_index == samples-1){
      MPU.x_mean = MPU.x_sum/samples;
      MPU.y_mean = MPU.y_sum/samples;
      MPU.z_mean = MPU.z_sum/samples;
      MPU.x_skew = skew_(MPU.x,MPU.x_mean,samples);
      MPU.y_skew = skew_(MPU.y,MPU.y_mean,samples);
      MPU.z_skew = skew_(MPU.z,MPU.z_mean,samples);
      #ifdef DEBUG
        /*
        Serial3.print("MPU.x_mean = ");Serial3.println(MPU.x_mean);
        Serial3.print("MPU.y_mean = ");Serial3.println(MPU.y_mean);
        Serial3.print("MPU.z_mean = ");Serial3.println(MPU.z_mean);
        */
        /*
        Serial3.print("x_skew = ");Serial3.println(MPU.x_skew);
        Serial3.print("y_skew = ");Serial3.println(MPU.y_skew);
        Serial3.print("z_skew = ");Serial3.println(MPU.z_skew);
        */
        Serial3.print(MPU.x_skew);Serial3.print(",");
        Serial3.print(MPU.y_skew);Serial3.print(",");
        Serial3.print(MPU.z_skew);Serial3.println(",");
      #endif
      //Normalise values.
      MPU.x_skew = (MPU.x_skew - x_skew_min) / (x_skew_max-x_skew_min);
      MPU.y_skew = (MPU.x_skew - y_skew_min) / (y_skew_max-y_skew_min);
      MPU.z_skew = (MPU.z_skew - z_skew_min) / (z_skew_max-z_skew_min);

      writeFloat(MPU.x_skew,inputRegisters,0);
      writeFloat(MPU.y_skew,inputRegisters,2);
      writeFloat(MPU.z_skew,inputRegisters,4);
      sample_index = 0;
      MPU = {0};
      break;
    }
  }
}




/*
 * ESP32 uses littel endian to write flaot values to modbus registers.
 * First it writes the lower 16 bits, then it writes is the upper 16 bits.
 * 
*/

float getFloat(uint16_t * array,int position) {
  union converter var;
  var.u32 = ((uint32_t)array[position+1] << 16) | array[position];
  return var.f;
}

void setup() {
  #if DEBUG
  Serial3.begin(9600);
  #endif
  Wire.begin();
  MPU6050Config();
  
  //Configure PINs
  
  pinMode(PC13,OUTPUT);                 //Indicator for Pump status.
  pinMode(CURRENT_SENSOR, INPUT);       //Current sensor analog read pin.
  pinMode(PUMP, OUTPUT);                //Pump (ON/OFF) control pin 
  pinMode(FLOW_METER,INPUT_PULLUP);     //Flow meter pin.
  pinMode(MPU_INT_PIN,INPUT_PULLDOWN);  //Interrupt pin from MPU6050.
  
  modbus.configureCoils(coils, 1);      
  modbus.configureInputRegisters(inputRegisters, 12);  
  modbus.begin(1, 9600);

  //t_previous = millis();
  
  attachInterrupt(digitalPinToInterrupt(MPU_INT_PIN), onDataReady, RISING);       //Interrupt configuration with pin PA0 to read data when it is ready from MPU6050.
  attachInterrupt(digitalPinToInterrupt(FLOW_METER), pulseCounter, FALLING);      //Interrupt configuration with pin PA5 to count pulses from flow meter.

}


//x[0-1] y[2-3] z[4-5] current[6-7] flow_rate[8-9] total_flow[10-11]
bool last_status = false;
void loop() {
  modbus.poll();
  digitalWrite(PUMP,!coils[0]);
  if(coils[0]&&!last_status){
    t_previous = millis();
  }

  if(coils[0]){
    //if(1){
    digitalWrite(PUMP,LOW);
    MPU6050Read();
    writeFloat(getCurrent(),inputRegisters,6);
    updateFlow();
    writeFloat(flow_mil,inputRegisters,8);
    writeFloat(total_flow,inputRegisters,10);
    digitalWrite(PC13,LOW);
    /*
    #if DEBUG
      //Serial3.print("sample_index = ");Serial3.println(sample_index);
      Serial3.print("total_flow = ");Serial3.println(total_flow);
      Serial3.print("flow_mil = ");Serial3.println(flow_rate);
      Serial3.print("Current = ");Serial3.println(getCurrent());
    #endif
    */
    last_status = true;
  }
  
  if(!coils[0]&&last_status){
      memset(inputRegisters, 0, sizeof(inputRegisters)); 
      total_flow = 0.0;
      flow_rate = 0.0;
      digitalWrite(PC13,HIGH);
      last_status = false;
  }

}

